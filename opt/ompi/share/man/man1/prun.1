.\" Automatically generated by Pandoc 2.11.3
.\"
.TH "prun" "1" "" "2021-02-04" "PRTE"
.hy
.SH NAME
.PP
prun - Execute serial and parallel jobs with the PMIx Reference Server.
.SH SYNOPSIS
.PP
Single Process Multiple Data (SPMD) Model:
.IP
.nf
\f[C]
prun [ options ] <program> [ <args> ]
\f[R]
.fi
.PP
Multiple Instruction Multiple Data (MIMD) Model:
.IP
.nf
\f[C]
prun [ global_options ] \[rs]
    [ local_options1 ] <program1> [ <args1> ] : \[rs]
    [ local_options2 ] <program2> [ <args2> ] : \[rs]
    ... : \[rs]
    [ local_optionsN ] <programN> [ <argsN> ]
\f[R]
.fi
.PP
Note that in both models, invoking \f[C]prun\f[R] via an absolute path
name is equivalent to specifying the \f[C]--prefix\f[R] option with a
\f[C]<dir>\f[R] value equivalent to the directory where \f[C]prun\f[R]
resides, minus its last subdirectory.
For example:
.IP
.nf
\f[C]
$ /usr/local/bin/prun ...
\f[R]
.fi
.PP
is equivalent to
.IP
.nf
\f[C]
$ prun --prefix /usr/local
\f[R]
.fi
.SH QUICK SUMMARY
.PP
If you are simply looking for how to run an application, you probably
want to use a command line of the following form:
.IP
.nf
\f[C]
$ prun [ -np X ] [ --hostfile <filename> ] <program>
\f[R]
.fi
.PP
This will run X copies of \f[C]<program>\f[R] in your current run-time
environment (if running under a supported resource manager, PSRVR\[cq]s
\f[C]prun\f[R] will usually automatically use the corresponding resource
manager process starter, as opposed to, for example,
\f[C]rsh or\f[R]ssh\[ga], which require the use of a hostfile, or will
default to running all X copies on the localhost), scheduling (by
default) in a round-robin fashion by CPU slot.
See the rest of this page for more details.
.PP
Please note that prun automatically binds processes.
Three binding patterns are used in the absence of any further
directives:
.TP
\f[B]\f[CB]Bind to core:\f[B]\f[R]
when the number of processes is <= 2
.TP
\f[B]\f[CB]Bind to socket:\f[B]\f[R]
when the number of processes is > 2
.TP
\f[B]\f[CB]Bind to none:\f[B]\f[R]
when oversubscribed
.PP
If your application uses threads, then you probably want to ensure that
you are either not bound at all (by specifying
\f[C]--bind-to none\f[R]), or bound to multiple cores using an
appropriate binding level or specific number of processing elements per
application process.
.SH OPTIONS
.PP
\f[C]prun\f[R] will send the name of the directory where it was invoked
on the local node to each of the remote nodes, and attempt to change to
that directory.
See the \[lq]Current Working Directory\[rq] section below for further
details.
.TP
\f[B]\f[CB]<program>\f[B]\f[R]
The program executable.
This is identified as the first non-recognized argument to prun.
.TP
\f[B]\f[CB]<args>\f[B]\f[R]
Pass these run-time arguments to every new process.
These must always be the last arguments to \f[C]prun\f[R].
If an app context file is used, \f[C]<args>\f[R] will be ignored.
.TP
\f[B]\f[CB]-h, --help\f[B]\f[R]
Display help for this command
.TP
\f[B]\f[CB]-q, --quiet\f[B]\f[R]
Suppress informative messages from prun during application execution.
.TP
\f[B]\f[CB]-v, --verbose\f[B]\f[R]
Be verbose
.TP
\f[B]\f[CB]-V, --version\f[B]\f[R]
Print version number.
If no other arguments are given, this will also cause prun to exit.
.TP
\f[B]\f[CB]-N <num>\f[B]\f[R]
Launch num processes per node on all allocated nodes (synonym for
npernode).
.TP
\f[B]\f[CB]-display-map, --display-map\f[B]\f[R]
Display a table showing the mapped location of each process prior to
launch.
.TP
\f[B]\f[CB]-display-allocation, --display-allocation\f[B]\f[R]
Display the detected resource allocation.
.TP
\f[B]\f[CB]-output-proctable, --output-proctable\f[B]\f[R]
Output the debugger proctable after launch.
.TP
\f[B]\f[CB]-max-vm-size, --max-vm-size <size>\f[B]\f[R]
Number of processes to run.
.TP
\f[B]\f[CB]-novm, --novm\f[B]\f[R]
Execute without creating an allocation-spanning virtual machine (only
start daemons on nodes hosting application procs).
.TP
\f[B]\f[CB]-hnp, --hnp <arg0>\f[B]\f[R]
Specify the URI of the psrvr process, or the name of the file (specified
as file:filename) that contains that info.
.PP
Use one of the following options to specify which hosts (nodes) within
the psrvr to run on.
.TP
\f[B]\f[CB]-H, -host, --host <host1,host2,...,hostN>\f[B]\f[R]
List of hosts on which to invoke processes.
Pass +e to allocate only onto empty nodes or +e:N to allocate onto nodes
at least N of which are empty (i.e.\ exclusive to this prun instance).
.TP
\f[B]\f[CB]-hostfile, --hostfile <hostfile>\f[B]\f[R]
Provide a hostfile to use.
.TP
\f[B]\f[CB]-default-hostfile, --default-hostfile <hostfile>\f[B]\f[R]
Provide a default hostfile.
.TP
\f[B]\f[CB]-machinefile, --machinefile <machinefile>\f[B]\f[R]
Synonym for \f[C]-hostfile\f[R].
.TP
\f[B]\f[CB]-cpu-set, --cpu-set <list>\f[B]\f[R]
Restrict launched processes to the specified logical cpus on each node
(comma-separated list).
Note that the binding options will still apply within the specified
envelope - e.g., you can elect to bind each process to only one cpu
within the specified cpu set.
.PP
The following options specify the number of processes to launch.
Note that none of the options imply a particular binding policy - e.g.,
requesting N processes for each socket does not imply that the processes
will be bound to the socket.
.TP
\f[B]\f[CB]-c, -n, --n, -np <#>\f[B]\f[R]
Run this many copies of the program on the given nodes.
This option indicates that the specified file is an executable program
and not an application context.
If no value is provided for the number of copies to execute (i.e.,
neither the \[lq]-np\[rq] nor its synonyms are provided on the command
line), prun will automatically execute a copy of the program on each
process slot (see below for description of a \[lq]process slot\[rq]).
This feature, however, can only be used in the SPMD model and will
return an error (without beginning execution of the application)
otherwise.
.TP
\f[B]\f[CB]-map-by,----map-by ppr:N:<object>\f[B]\f[R]
Launch N times the number of objects of the specified type on each node.
.TP
\f[B]\f[CB]-npersocket, --npersocket <#persocket>\f[B]\f[R]
On each node, launch this many processes times the number of processor
sockets on the node.
The \f[C]-npersocket\f[R] option also turns on the
\f[C]-bind-to-socket\f[R] option.
(deprecated in favor of \[en]map-by ppr:n:socket)
.TP
\f[B]\f[CB]-npernode, --npernode <#pernode>\f[B]\f[R]
On each node, launch this many processes.
(deprecated in favor of \[en]map-by ppr:n:node)
.TP
\f[B]\f[CB]-pernode, --pernode\f[B]\f[R]
On each node, launch one process \[en] equivalent to \f[C]-npernode\f[R]
1.
(deprecated in favor of \[en]map-by ppr:1:node)
.PP
To map processes:
.TP
\f[B]\f[CB]-map-by,--map-by <foo>\f[B]\f[R]
Map to the specified object, defaults to \f[C]socket\f[R].
Supported options include \f[C]slot\f[R], \f[C]hwthread\f[R],
\f[C]core\f[R], \f[C]L1cache\f[R], \f[C]L2cache\f[R], \f[C]L3cache\f[R],
\f[C]socket\f[R], \f[C]numa\f[R], \f[C]board\f[R], \f[C]node\f[R],
\f[C]sequential\f[R], \f[C]distance\f[R], and \f[C]ppr\f[R].
Any object can include modifiers by adding a : and any combination of
PE=n (bind n processing elements to each proc), SPAN (load balance the
processes across the allocation), OVERSUBSCRIBE (allow more processes on
a node than processing elements), and NOOVERSUBSCRIBE.
This includes PPR, where the pattern would be terminated by another
colon to separate it from the modifiers.
.TP
\f[B]\f[CB]-bycore, --bycore\f[B]\f[R]
Map processes by core (deprecated in favor of \[en]map-by core)
.TP
\f[B]\f[CB]-byslot, --byslot\f[B]\f[R]
Map and rank processes round-robin by slot.
.TP
\f[B]\f[CB]-nolocal, --nolocal\f[B]\f[R]
Do not run any copies of the launched application on the same node as
prun is running.
This option will override listing the localhost with \f[C]--host\f[R] or
any other host-specifying mechanism.
.TP
\f[B]\f[CB]-nooversubscribe, --nooversubscribe\f[B]\f[R]
Do not oversubscribe any nodes; error (without starting any processes)
if the requested number of processes would cause oversubscription.
This option implicitly sets \[lq]max_slots\[rq] equal to the
\[lq]slots\[rq] value for each node.
(Enabled by default).
.TP
\f[B]\f[CB]-oversubscribe, --oversubscribe\f[B]\f[R]
Nodes are allowed to be oversubscribed, even on a managed system, and
overloading of processing elements.
.TP
\f[B]\f[CB]-bynode, --bynode\f[B]\f[R]
Launch processes one per node, cycling by node in a round-robin fashion.
This spreads processes evenly among nodes and assigns ranks in a
round-robin, \[lq]by node\[rq] manner.
.TP
\f[B]\f[CB]-cpu-list, --cpu-list <cpus>\f[B]\f[R]
List of processor IDs to bind processes to [default=NULL].
.PP
To order processes\[cq] ranks:
.TP
\f[B]\f[CB]--rank-by <foo>\f[B]\f[R]
Rank in round-robin fashion according to the specified object, defaults
to \f[C]slot\f[R].
Supported options include slot, hwthread, core, L1cache, L2cache,
L3cache, socket, numa, board, and node.
.PP
For process binding:
.TP
\f[B]\f[CB]--bind-to <foo>\f[B]\f[R]
Bind processes to the specified object, defaults to \f[C]core\f[R].
Supported options include slot, hwthread, core, l1cache, l2cache,
l3cache, socket, numa, board, and none.
.TP
\f[B]\f[CB]-cpus-per-proc, --cpus-per-proc <#perproc>\f[B]\f[R]
Bind each process to the specified number of cpus.
(deprecated in favor of \[en]map-by :PE=n)
.TP
\f[B]\f[CB]-cpus-per-rank, --cpus-per-rank <#perrank>\f[B]\f[R]
Alias for \f[C]-cpus-per-proc\f[R].
(deprecated in favor of \[en]map-by :PE=n)
.TP
\f[B]\f[CB]-bind-to-core, --bind-to-core\f[B]\f[R]
Bind processes to cores (deprecated in favor of \[en]bind-to core)
.TP
\f[B]\f[CB]-bind-to-socket, --bind-to-socket\f[B]\f[R]
Bind processes to processor sockets (deprecated in favor of \[en]bind-to
socket)
.TP
\f[B]\f[CB]-report-bindings, --report-bindings\f[B]\f[R]
Report any bindings for launched processes.
.PP
For rankfiles:
.TP
\f[B]\f[CB]-rf, --rankfile <rankfile>\f[B]\f[R]
Provide a rankfile file.
.PP
To manage standard I/O:
.TP
\f[B]\f[CB]-output-filename, --output-filename <filename>\f[B]\f[R]
Redirect the stdout, stderr, and stddiag of all processes to a
process-unique version of the specified filename.
Any directories in the filename will automatically be created.
Each output file will consist of filename.id, where the id will be the
processes\[cq] rank, left-filled with zero\[cq]s for correct ordering in
listings.B oth stdout and stderr will be redirected to the file.
A relative path value will be converted to an absolute path based on the
cwd where prun is executed.
Note that this \f[I]will not\f[R] work on environments where the file
system on compute nodes differs from that where prun is executed.
This option accepts one case-insensitive directive, specified after a
colon: NOCOPY indicates that the output is not to be echoed to the
terminal.
.TP
\f[B]\f[CB]-output-directory, --output-directory <path>\f[B]\f[R]
Redirect the stdout, stderr, and stddiag of all processes to a
process-unique location consisting of \[lq]//rank.id/stdout[err]\[rq],
where the id will be the processes\[cq] rank, left-filled with
zero\[cq]s for correct ordering in listings.
Any directories in the filename will automatically be created.
A relative path value will be converted to an absolute path based on the
cwd where prun is executed.
Note that this \f[I]will not\f[R] work on environments where the file
system on compute nodes differs from that where prun is executed.
This option also supports two case-insensitive directives, specified in
comma-delimited form after a colon: NOJOBID (omits the jobid directory
layer) and NOCOPY (do not copy the output to the terminal).
.TP
\f[B]\f[CB]-stdin, --stdin <rank>\f[B]\f[R]
The rank of the process that is to receive stdin.
The default is to forward stdin to rank 0, but this option can be used
to forward stdin to any process.
It is also acceptable to specify \f[C]none\f[R], indicating that no
processes are to receive stdin.
.TP
\f[B]\f[CB]-merge-stderr-to-stdout, --merge-stderr-to-stdout\f[B]\f[R]
Merge stderr to stdout for each process.
.TP
\f[B]\f[CB]-tag-output, --tag-output\f[B]\f[R]
Tag each line of output to stdout, stderr, and stddiag with
\f[C][jobid, MCW_rank]<stdxxx>\f[R] indicating the process jobid and
rank of the process that generated the output, and the channel which
generated it.
.TP
\f[B]\f[CB]-timestamp-output, --timestamp-output\f[B]\f[R]
Timestamp each line of output to stdout, stderr, and stddiag.
.TP
\f[B]\f[CB]-xml, --xml\f[B]\f[R]
Provide all output to stdout, stderr, and stddiag in an xml format.
.TP
\f[B]\f[CB]-xml-file, --xml-file <filename>\f[B]\f[R]
Provide all output in XML format to the specified file.
.TP
\f[B]\f[CB]-xterm, --xterm <ranks>\f[B]\f[R]
Display the output from the processes identified by their ranks in
separate xterm windows.
The ranks are specified as a comma-separated list of ranges, with a -1
indicating all.
A separate window will be created for each specified process.
\f[B]Note:\f[R] xterm will normally terminate the window upon
termination of the process running within it.
However, by adding a \[lq]!\[rq] to the end of the list of specified
ranks, the proper options will be provided to ensure that xterm keeps
the window open \f[I]after\f[R] the process terminates, thus allowing
you to see the process\[cq] output.
Each xterm window will subsequently need to be manually closed.
\f[B]Note:\f[R] In some environments, xterm may require that the
executable be in the user\[cq]s path, or be specified in absolute or
relative terms.
Thus, it may be necessary to specify a local executable as
\[lq]./foo\[rq] instead of just \[lq]foo\[rq].
If xterm fails to find the executable, prun will hang, but still respond
correctly to a ctrl-c.\ If this happens, please check that the
executable is being specified correctly and try again.
.PP
To manage files and runtime environment:
.TP
\f[B]\f[CB]-path, --path <path>\f[B]\f[R]
that will be used when attempting to locate the requested executables.
This is used prior to using the local PATH setting.
.TP
\f[B]\f[CB]--prefix <dir>\f[B]\f[R]
Prefix directory that will be used to set the \f[C]PATH\f[R] and
\f[C]LD_LIBRARY_PATH\f[R] on the remote node before invoking the target
process.
See the \[lq]Remote Execution\[rq] section, below.
.TP
\f[B]\f[CB]--noprefix\f[B]\f[R]
Disable the automatic \[en]prefix behavior
.TP
\f[B]\f[CB]-s, --preload-binary\f[B]\f[R]
Copy the specified executable(s) to remote machines prior to starting
remote processes.
The executables will be copied to the session directory and will be
deleted upon completion of the job.
.TP
\f[B]\f[CB]--preload-files <files>\f[B]\f[R]
Preload the comma separated list of files to the current working
directory of the remote machines where processes will be launched prior
to starting those processes.
.TP
\f[B]\f[CB]-set-cwd-to-session-dir, --set-cwd-to-session-dir\f[B]\f[R]
Set the working directory of the started processes to their session
directory.
.TP
\f[B]\f[CB]-wd <dir>\f[B]\f[R]
Synonym for \f[C]-wdir\f[R].
.TP
\f[B]\f[CB]-wdir <dir>\f[B]\f[R]
Change to the directory
.RS
.PP
before the user\[cq]s program executes.
See the \[lq]Current Working Directory\[rq] section for notes on
relative paths.
\f[B]Note:\f[R] If the \f[C]-wdir\f[R] option appears both on the
command line and in an application context, the context will take
precedence over the command line.
Thus, if the path to the desired wdir is different on the backend nodes,
then it must be specified as an absolute path that is correct for the
backend node.
.RE
.TP
\f[B]\f[CB]-x <env>\f[B]\f[R]
Export the specified environment variables to the remote nodes before
executing the program.
Only one environment variable can be specified per \f[C]-x\f[R] option.
Existing environment variables can be specified or new variable names
specified with corresponding values.
For example: \f[C]$ prun -x DISPLAY -x OFILE=/tmp/out ...\f[R]
.PP
The parser for the \f[C]-x\f[R] option is not very sophisticated; it
does not even understand quoted values.
Users are advised to set variables in the environment, and then use
\f[C]-x\f[R] to export (not define) them.
.PP
Setting MCA parameters:
.TP
\f[B]\f[CB]-gpmca, --gpmca <key> <value>\f[B]\f[R]
Pass global MCA parameters that are applicable to all contexts.
\f[C]<key>\f[R] is the parameter name; \f[C]<value>\f[R] is the
parameter value.
.TP
\f[B]\f[CB]-pmca, --pmca <key> <value>\f[B]\f[R]
Send arguments to various MCA modules.
See the \[lq]MCA\[rq] section, below.
.TP
\f[B]\f[CB]-am <arg0>\f[B]\f[R]
Aggregate MCA parameter set file list.
.TP
\f[B]\f[CB]-tune, --tune <tune_file>\f[B]\f[R]
Specify a tune file to set arguments for various MCA modules and
environment variables.
See the \[lq]Setting MCA parameters and environment variables from
file\[rq] section, below.
.PP
For debugging:
.TP
\f[B]\f[CB]-debug, --debug\f[B]\f[R]
Invoke the user-level debugger indicated by the
\f[C]prte_base_user_debugger\f[R] MCA parameter.
.TP
\f[B]\f[CB]--get-stack-traces\f[B]\f[R]
When paired with the \f[C]--timeout\f[R] option, \f[C]prun\f[R] will
obtain and print out stack traces from all launched processes that are
still alive when the timeout expires.
Note that obtaining stack traces can take a little time and produce a
lot of output, especially for large process-count jobs.
.TP
\f[B]\f[CB]-debugger, --debugger <args>\f[B]\f[R]
Sequence of debuggers to search for when \f[C]--debug\f[R] is used
(i.e.\ a synonym for \f[C]prte_base_user_debugger\f[R] MCA parameter).
.TP
\f[B]\f[CB]--timeout <seconds>\f[B]\f[R]
The maximum number of seconds that \f[C]prun\f[R] will run.
After this many seconds, \f[C]prun\f[R] will abort the launched job and
exit with a non-zero exit status.
Using \f[C]--timeout\f[R] can be also useful when combined with the
\f[C]--get-stack-traces\f[R] option.
.TP
\f[B]\f[CB]-tv, --tv\f[B]\f[R]
Launch processes under the TotalView debugger.
Deprecated backwards compatibility flag.
Synonym for \f[C]--debug\f[R].
.PP
There are also other options:
.TP
\f[B]\f[CB]--allow-run-as-root\f[B]\f[R]
Allow \f[C]prun\f[R] to run when executed by the root user
(\f[C]prun\f[R] defaults to aborting when launched as the root user).
.TP
\f[B]\f[CB]--app <appfile>\f[B]\f[R]
Provide an appfile, ignoring all other command line options.
.TP
\f[B]\f[CB]-cf, --cartofile <cartofile>\f[B]\f[R]
Provide a cartography file.
.TP
\f[B]\f[CB]-continuous, --continuous\f[B]\f[R]
Job is to run until explicitly terminated.
.TP
\f[B]\f[CB]-disable-recovery, --disable-recovery\f[B]\f[R]
Disable recovery (resets all recovery options to off).
.TP
\f[B]\f[CB]-do-not-launch, --do-not-launch\f[B]\f[R]
Perform all necessary operations to prepare to launch the application,
but do not actually launch it.
.TP
\f[B]\f[CB]-do-not-resolve, --do-not-resolve\f[B]\f[R]
Do not attempt to resolve interfaces.
.TP
\f[B]\f[CB]-enable-recovery, --enable-recovery\f[B]\f[R]
Enable recovery from process failure [Default = disabled].
.TP
\f[B]\f[CB]-index-argv-by-rank, --index-argv-by-rank\f[B]\f[R]
Uniquely index argv[0] for each process using its rank.
.TP
\f[B]\f[CB]-max-restarts, --max-restarts <num>\f[B]\f[R]
Max number of times to restart a failed process.
.TP
\f[B]\f[CB]--ppr <list>\f[B]\f[R]
Comma-separated list of number of processes on a given resource type
[default: none].
(deprecated in favor of \[en]map-by ppr:)
.TP
\f[B]\f[CB]-report-child-jobs-separately, --report-child-jobs-separately\f[B]\f[R]
Return the exit status of the primary job only.
.TP
\f[B]\f[CB]-report-events, --report-events <URI>\f[B]\f[R]
Report events to a tool listening at the specified URI.
.TP
\f[B]\f[CB]-report-pid, --report-pid <channel>\f[B]\f[R]
Print out prun\[cq]s PID during startup.
The channel must be either a `-' to indicate that the pid is to be
output to stdout, a `+' to indicate that the pid is to be output to
stderr, or a filename to which the pid is to be written.
.TP
\f[B]\f[CB]-report-uri, --report-uri <channel>\f[B]\f[R]
Print out prun\[cq]s URI during startup.
The channel must be either a `-' to indicate that the URI is to be
output to stdout, a `+' to indicate that the URI is to be output to
stderr, or a filename to which the URI is to be written.
.TP
\f[B]\f[CB]-show-progress, --show-progress\f[B]\f[R]
Output a brief periodic report on launch progress.
.TP
\f[B]\f[CB]-terminate, --terminate\f[B]\f[R]
Terminate the DVM.
.TP
\f[B]\f[CB]-use-hwthread-cpus, --use-hwthread-cpus\f[B]\f[R]
Use hardware threads as independent cpus.
.TP
\f[B]\f[CB]-use-regexp, --use-regexp\f[B]\f[R]
Use regular expressions for launch.
.PP
The following options are useful for developers; they are not generally
useful to most users:
.TP
\f[B]\f[CB]-d, --debug-devel\f[B]\f[R]
Enable debugging.
This is not generally useful for most users.
.TP
\f[B]\f[CB]-display-devel-allocation, --display-devel-allocation\f[B]\f[R]
Display a detailed list of the allocation being used by this job.
.TP
\f[B]\f[CB]-display-devel-map, --display-devel-map\f[B]\f[R]
Display a more detailed table showing the mapped location of each
process prior to launch.
.TP
\f[B]\f[CB]-display-diffable-map, --display-diffable-map\f[B]\f[R]
Display a diffable process map just before launch.
.TP
\f[B]\f[CB]-display-topo, --display-topo\f[B]\f[R]
Display the topology as part of the process map just before launch.
.TP
\f[B]\f[CB]--report-state-on-timeout\f[B]\f[R]
When paired with the \f[C]--timeout\f[R] command line option, report the
run-time subsystem state of each process when the timeout expires.
.PP
There may be other options listed with \f[C]prun --help\f[R].
.SH DESCRIPTION
.PP
One invocation of \f[C]prun\f[R] starts an application running under
PSRVR.
If the application is single process multiple data (SPMD), the
application can be specified on the \f[C]prun\f[R] command line.
.PP
If the application is multiple instruction multiple data (MIMD),
comprising of multiple programs, the set of programs and argument can be
specified in one of two ways: Extended Command Line Arguments, and
Application Context.
.PP
An application context describes the MIMD program set including all
arguments in a separate file.
This file essentially contains multiple \f[C]prun\f[R] command lines,
less the command name itself.
The ability to specify different options for different instantiations of
a program is another reason to use an application context.
.PP
Extended command line arguments allow for the description of the
application layout on the command line using colons (\f[C]:\f[R]) to
separate the specification of programs and arguments.
Some options are globally set across all specified programs
(e.g.\ \[en]hostfile), while others are specific to a single program
(e.g.\ -np).
.SS Specifying Host Nodes
.PP
Host nodes can be identified on the \f[C]prun\f[R] command line with the
\f[C]-host\f[R] option or in a hostfile.
.PP
For example,
.TP
prun -H aa,aa,bb ./a.out
launches two processes on node aa and one on bb.
.PP
Or, consider the hostfile
.IP
.nf
\f[C]
$ cat myhostfile aa slots=2 bb slots=2 cc slots=2
\f[R]
.fi
.PP
Here, we list both the host names (aa, bb, and cc) but also how many
\[lq]slots\[rq] there are for each.
Slots indicate how many processes can potentially execute on a node.
For best performance, the number of slots may be chosen to be the number
of cores on the node or the number of processor sockets.
If the hostfile does not provide slots information, PSRVR will attempt
to discover the number of cores (or hwthreads, if the
use-hwthreads-as-cpus option is set) and set the number of slots to that
value.
This default behavior also occurs when specifying the \f[C]-host\f[R]
option with a single hostname.
Thus, the command
.TP
prun -H aa ./a.out
launches a number of processes equal to the number of cores on node aa.
.TP
prun -hostfile myhostfile ./a.out
will launch two processes on each of the three nodes.
.TP
prun -hostfile myhostfile -host aa ./a.out
will launch two processes, both on node aa.
.TP
prun -hostfile myhostfile -host dd ./a.out
will find no hosts to run on and abort with an error.
That is, the specified host dd is not in the specified hostfile.
.PP
When running under resource managers (e.g., SLURM, Torque, etc.), PSRVR
will obtain both the hostnames and the number of slots directly from the
resource manger.
.SS Specifying Number of Processes
.PP
As we have just seen, the number of processes to run can be set using
the hostfile.
Other mechanisms exist.
.PP
The number of processes launched can be specified as a multiple of the
number of nodes or processor sockets available.
For example,
.TP
prun -H aa,bb -npersocket 2 ./a.out
launches processes 0-3 on node aa and process 4-7 on node bb, where aa
and bb are both dual-socket nodes.
The \f[C]-npersocket\f[R] option also turns on the
\f[C]-bind-to-socket\f[R] option, which is discussed in a later section.
.TP
prun -H aa,bb -npernode 2 ./a.out
launches processes 0-1 on node aa and processes 2-3 on node bb.
.TP
prun -H aa,bb -npernode 1 ./a.out
launches one process per host node.
.TP
prun -H aa,bb -pernode ./a.out
is the same as \f[C]-npernode\f[R] 1.
.PP
Another alternative is to specify the number of processes with the
\f[C]-np\f[R] option.
Consider now the hostfile
.IP
.nf
\f[C]
$ cat myhostfile aa slots=4 bb slots=4 cc slots=4
\f[R]
.fi
.PP
Now,
.TP
\f[B]\f[CB]prun -hostfile myhostfile -np 6 ./a.out\f[B]\f[R]
will launch processes 0-3 on node aa and processes 4-5 on node bb.
The remaining slots in the hostfile will not be used since the
\f[C]-np\f[R] option indicated that only 6 processes should be launched.
.SS Mapping Processes to Nodes: Using Policies
.PP
The examples above illustrate the default mapping of process processes
to nodes.
This mapping can also be controlled with various \f[C]prun\f[R] options
that describe mapping policies.
.PP
Consider the same hostfile as above, again with \f[C]-np\f[R] 6:
.PP
node aa node bb node cc
.PP
prun 0 1 2 3 4 5
.PP
prun \[en]map-by node 0 3 1 4 2 5
.PP
prun -nolocal 0 1 2 3 4 5
.PP
The \f[C]--map-by node\f[R] option will load balance the processes
across the available nodes, numbering each process in a round-robin
fashion.
.PP
The \f[C]-nolocal\f[R] option prevents any processes from being mapped
onto the local host (in this case node aa).
While \f[C]prun\f[R] typically consumes few system resources,
\f[C]-nolocal\f[R] can be helpful for launching very large jobs where
\f[C]prun\f[R] may actually need to use noticeable amounts of memory
and/or processing time.
.PP
Just as \f[C]-np\f[R] can specify fewer processes than there are slots,
it can also oversubscribe the slots.
For example, with the same hostfile:
.TP
prun -hostfile myhostfile -np 14 ./a.out
will launch processes 0-3 on node aa, 4-7 on bb, and 8-11 on cc.
It will then add the remaining two processes to whichever nodes it
chooses.
.PP
One can also specify limits to oversubscription.
For example, with the same hostfile:
.TP
prun -hostfile myhostfile -np 14 -nooversubscribe ./a.out
will produce an error since \f[C]-nooversubscribe\f[R] prevents
oversubscription.
.PP
Limits to oversubscription can also be specified in the hostfile itself:
% cat myhostfile aa slots=4 max_slots=4 bb max_slots=4 cc slots=4
.PP
The \f[C]max_slots\f[R] field specifies such a limit.
When it does, the \f[C]slots\f[R] value defaults to the limit.
Now:
.TP
prun -hostfile myhostfile -np 14 ./a.out
causes the first 12 processes to be launched as before, but the
remaining two processes will be forced onto node cc.
The other two nodes are protected by the hostfile against
oversubscription by this job.
.PP
Using the \f[C]--nooversubscribe\f[R] option can be helpful since PSRVR
currently does not get \[lq]max_slots\[rq] values from the resource
manager.
.PP
Of course, \f[C]-np\f[R] can also be used with the \f[C]-H\f[R] or
\f[C]-host\f[R] option.
For example,
.TP
prun -H aa,bb -np 8 ./a.out
launches 8 processes.
Since only two hosts are specified, after the first two processes are
mapped, one to aa and one to bb, the remaining processes oversubscribe
the specified hosts.
.PP
And here is a MIMD example:
.TP
prun -H aa -np 1 hostname : -H bb,cc -np 2 uptime
will launch process 0 running \f[C]hostname\f[R] on node aa and
processes 1 and 2 each running \f[C]uptime\f[R] on nodes bb and cc,
respectively.
.SS Mapping, Ranking, and Binding: Oh My!
.PP
PSRVR employs a three-phase procedure for assigning process locations
and ranks:
.TP
\f[B]Mapping\f[R]
Assigns a default location to each process
.TP
\f[B]Ranking\f[R]
Assigns a rank value to each process
.TP
\f[B]Binding\f[R]
Constrains each process to run on specific processors
.PP
The \f[I]mapping\f[R] step is used to assign a default location to each
process based on the mapper being employed.
Mapping by slot, node, and sequentially results in the assignment of the
processes to the node level.
In contrast, mapping by object, allows the mapper to assign the process
to an actual object on each node.
.PP
\f[B]Note:\f[R] the location assigned to the process is independent of
where it will be bound - the assignment is used solely as input to the
binding algorithm.
.PP
The mapping of process processes to nodes can be defined not just with
general policies but also, if necessary, using arbitrary mappings that
cannot be described by a simple policy.
One can use the \[lq]sequential mapper,\[rq] which reads the hostfile
line by line, assigning processes to nodes in whatever order the
hostfile specifies.
Use the \f[C]-pmca rmaps seq\f[R] option.
For example, using the same hostfile as before:
.PP
prun -hostfile myhostfile -pmca rmaps seq ./a.out
.PP
will launch three processes, one on each of nodes aa, bb, and cc,
respectively.
The slot counts don\[cq]t matter; one process is launched per line on
whatever node is listed on the line.
.PP
Another way to specify arbitrary mappings is with a rankfile, which
gives you detailed control over process binding as well.
Rankfiles are discussed below.
.PP
The second phase focuses on the \f[I]ranking\f[R] of the process within
the job.
PSRVR separates this from the mapping procedure to allow more
flexibility in the relative placement of processes.
This is best illustrated by considering the following two cases where we
used the \[em]map-by ppr:2:socket option:
.PP
node aa node bb
.PP
rank-by core 0 1 ! 2 3 4 5 ! 6 7
.PP
rank-by socket 0 2 ! 1 3 4 6 ! 5 7
.PP
rank-by socket:span 0 4 ! 1 5 2 6 ! 3 7
.PP
Ranking by core and by slot provide the identical result - a simple
progression of ranks across each node.
Ranking by socket does a round-robin ranking within each node until all
processes have been assigned a rank, and then progresses to the next
node.
Adding the \f[C]span\f[R] modifier to the ranking directive causes the
ranking algorithm to treat the entire allocation as a single entity -
thus, the MCW ranks are assigned across all sockets before circling back
around to the beginning.
.PP
The \f[I]binding\f[R] phase actually binds each process to a given set
of processors.
This can improve performance if the operating system is placing
processes suboptimally.
For example, it might oversubscribe some multi-core processor sockets,
leaving other sockets idle; this can lead processes to contend
unnecessarily for common resources.
Or, it might spread processes out too widely; this can be suboptimal if
application performance is sensitive to interprocess communication
costs.
Binding can also keep the operating system from migrating processes
excessively, regardless of how optimally those processes were placed to
begin with.
.PP
The processors to be used for binding can be identified in terms of
topological groupings - e.g., binding to an l3cache will bind each
process to all processors within the scope of a single L3 cache within
their assigned location.
Thus, if a process is assigned by the mapper to a certain socket, then a
\f[C]---bind-to l3cache\f[R] directive will cause the process to be
bound to the processors that share a single L3 cache within that socket.
.PP
To help balance loads, the binding directive uses a round-robin method
when binding to levels lower than used in the mapper.
For example, consider the case where a job is mapped to the socket
level, and then bound to core.
Each socket will have multiple cores, so if multiple processes are
mapped to a given socket, the binding algorithm will assign each process
located to a socket to a unique core in a round-robin manner.
.PP
Alternatively, processes mapped by l2cache and then bound to socket will
simply be bound to all the processors in the socket where they are
located.
In this manner, users can exert detailed control over relative MCW rank
location and binding.
.PP
Finally, \f[C]--report-bindings\f[R] can be used to report bindings.
.PP
As an example, consider a node with two processor sockets, each
comprising four cores.
We run \f[C]prun\f[R] with \f[C]-np 4 --report-bindings\f[R] and the
following additional options:
.IP
.nf
\f[C]
% prun ... --map-by core --bind-to core [...] ... binding child
[...,0] to cpus 0001 [...] ... binding child [...,1] to cpus
0002 [...] ... binding child [...,2] to cpus 0004 [...] ...
binding child [...,3] to cpus 0008
\f[R]
.fi
.IP
.nf
\f[C]
% prun ... --map-by socket --bind-to socket [...] ... binding
child [...,0] to socket 0 cpus 000f [...] ... binding child
[...,1] to socket 1 cpus 00f0 [...] ... binding child [...,2]
to socket 0 cpus 000f [...] ... binding child [...,3] to socket 1
cpus 00f0
\f[R]
.fi
.IP
.nf
\f[C]
% prun ... --map-by core:PE=2 --bind-to core [...] ... binding
child [...,0] to cpus 0003 [...] ... binding child [...,1] to
cpus 000c [...] ... binding child [...,2] to cpus 0030 [...]
\&... binding child [...,3] to cpus 00c0
\f[R]
.fi
.IP
.nf
\f[C]
% prun ... --bind-to none
\f[R]
.fi
.PP
Here, \f[C]--report-bindings\f[R] shows the binding of each process as a
mask.
In the first case, the processes bind to successive cores as indicated
by the masks 0001, 0002, 0004, and 0008.
In the second case, processes bind to all cores on successive sockets as
indicated by the masks 000f and 00f0.
The processes cycle through the processor sockets in a round-robin
fashion as many times as are needed.
In the third case, the masks show us that 2 cores have been bound per
process.
In the fourth case, binding is turned off and no bindings are reported.
.PP
PSRVR\[cq]s support for process binding depends on the underlying
operating system.
Therefore, certain process binding options may not be available on every
system.
.PP
Process binding can also be set with MCA parameters.
Their usage is less convenient than that of \f[C]prun\f[R] options.
On the other hand, MCA parameters can be set not only on the
\f[C]prun\f[R] command line, but alternatively in a system or user
mca-params.conf file or as environment variables, as described in the
MCA section below.
Some examples include:
.PP
prun option MCA parameter key value
.PP
\[en]map-by core rmaps_base_mapping_policy core \[en]map-by socket
rmaps_base_mapping_policy socket \[en]rank-by core
rmaps_base_ranking_policy core \[en]bind-to core
hwloc_base_binding_policy core \[en]bind-to socket
hwloc_base_binding_policy socket \[en]bind-to none
hwloc_base_binding_policy none
.SS Rankfiles
.PP
Rankfiles are text files that specify detailed information about how
individual processes should be mapped to nodes, and to which
processor(s) they should be bound.
Each line of a rankfile specifies the location of one process.
The general form of each line in the rankfile is:
.PP
rank = slot=
.PP
For example:
.PP
$ cat myrankfile rank 0=aa slot=1:0-2 rank 1=bb slot=0:0,1 rank 2=cc
slot=1-2 $ prun -H aa,bb,cc,dd -rf myrankfile ./a.out
.PP
Means that
.PP
Rank 0 runs on node aa, bound to logical socket 1, cores 0-2.
Rank 1 runs on node bb, bound to logical socket 0, cores 0 and 1.
Rank 2 runs on node cc, bound to logical cores 1 and 2.
.PP
Rankfiles can alternatively be used to specify \f[I]physical\f[R]
processor locations.
In this case, the syntax is somewhat different.
Sockets are no longer recognized, and the slot number given must be the
number of the physical PU as most OS\[cq]s do not assign a unique
physical identifier to each core in the node.
Thus, a proper physical rankfile looks something like the following:
.PP
$ cat myphysicalrankfile rank 0=aa slot=1 rank 1=bb slot=8 rank 2=cc
slot=6
.PP
This means that
.PP
Rank 0 will run on node aa, bound to the core that contains physical PU
1 Rank 1 will run on node bb, bound to the core that contains physical
PU 8 Rank 2 will run on node cc, bound to the core that contains
physical PU 6
.PP
Rankfiles are treated as \f[I]logical\f[R] by default, and the MCA
parameter rmaps_rank_file_physical must be set to 1 to indicate that the
rankfile is to be considered as \f[I]physical\f[R].
.PP
The hostnames listed above are \[lq]absolute,\[rq] meaning that actual
resolveable hostnames are specified.
However, hostnames can also be specified as \[lq]relative,\[rq] meaning
that they are specified in relation to an externally-specified list of
hostnames (e.g., by prun\[cq]s \[en]host argument, a hostfile, or a job
scheduler).
.PP
The \[lq]relative\[rq] specification is of the form \[lq]+n\[rq], where
X is an integer specifying the Xth hostname in the set of all available
hostnames, indexed from 0.
For example:
.PP
$ cat myrankfile rank 0=+n0 slot=1:0-2 rank 1=+n1 slot=0:0,1 rank 2=+n2
slot=1-2 $ prun -H aa,bb,cc,dd -rf myrankfile ./a.out
.PP
All socket/core slot locations are be specified as \f[I]logical\f[R]
indexes.
You can use tools such as HWLOC\[cq]s \[lq]lstopo\[rq] to find the
logical indexes of socket and cores.
.SS Application Context or Executable Program?
.PP
To distinguish the two different forms, \f[C]prun\f[R] looks on the
command line for \f[C]--app\f[R] option.
If it is specified, then the file named on the command line is assumed
to be an application context.
If it is not specified, then the file is assumed to be an executable
program.
.SS Locating Files
.PP
If no relative or absolute path is specified for a file, prun will first
look for files by searching the directories specified by the
\f[C]--path\f[R] option.
If there is no \f[C]--path\f[R] option set or if the file is not found
at the \f[C]--path\f[R] location, then prun will search the user\[cq]s
PATH environment variable as defined on the source node(s).
.PP
If a relative directory is specified, it must be relative to the initial
working directory determined by the specific starter used.
For example when using the rsh or ssh starters, the initial directory is
$HOME by default.
Other starters may set the initial directory to the current working
directory from the invocation of \f[C]prun\f[R].
.SS Current Working Directory
.PP
The \f[C]-wdir\f[R] prun option (and its synonym, \f[C]-wd\f[R]) allows
the user to change to an arbitrary directory before the program is
invoked.
It can also be used in application context files to specify working
directories on specific nodes and/or for specific applications.
.PP
If the \f[C]-wdir\f[R] option appears both in a context file and on the
command line, the context file directory will override the command line
value.
.PP
If the \f[C]-wdir\f[R] option is specified, prun will attempt to change
to the specified directory on all of the remote nodes.
If this fails, \f[C]prun\f[R] will abort.
.PP
If the \f[C]-wdir\f[R] option is \f[B]not\f[R] specified, prun will send
the directory name where \f[C]prun\f[R] was invoked to each of the
remote nodes.
The remote nodes will try to change to that directory.
If they are unable (e.g., if the directory does not exist on that node),
then prun will use the default directory determined by the starter.
.PP
All directory changing occurs before the user\[cq]s program is invoked.
.SS Standard I/O
.PP
PSRVR directs UNIX standard input to /dev/null on all processes except
the rank 0 process.
The rank 0 process inherits standard input from \f[C]prun\f[R].
\f[B]Note:\f[R] The node that invoked \f[C]prun\f[R] need not be the
same as the node where the rank 0 process resides.
PSRVR handles the redirection of \f[C]prun\f[R]\[cq]s standard input to
the rank 0 process.
.PP
PSRVR directs UNIX standard output and error from remote nodes to the
node that invoked \f[C]prun\f[R] and prints it on the standard
output/error of \f[C]prun\f[R].
Local processes inherit the standard output/error of \f[C]prun\f[R] and
transfer to it directly.
.PP
Thus it is possible to redirect standard I/O for applications by using
the typical shell redirection procedure on \f[C]prun\f[R].
.IP
.nf
\f[C]
$ prun -np 2 my_app < my_input > my_output
\f[R]
.fi
.PP
Note that in this example \f[I]only\f[R] the rank 0 process will receive
the stream from \f[C]my_input\f[R] on stdin.
The stdin on all the other nodes will be tied to /dev/null.
However, the stdout from all nodes will be collected into the
\f[C]my_output\f[R] file.
.SS Signal Propagation
.PP
When prun receives a SIGTERM and SIGINT, it will attempt to kill the
entire job by sending all processes in the job a SIGTERM, waiting a
small number of seconds, then sending all processes in the job a
SIGKILL.
.PP
SIGUSR1 and SIGUSR2 signals received by prun are propagated to all
processes in the job.
.PP
A SIGTSTOP signal to prun will cause a SIGSTOP signal to be sent to all
of the programs started by prun and likewise a SIGCONT signal to prun
will cause a SIGCONT sent.
.PP
Other signals are not currently propagated by prun.
.SS Process Termination / Signal Handling
.PP
During the run of an application, if any process dies abnormally (either
exiting before invoking \f[C]PMIx_Finalize\f[R], or dying as the result
of a signal), \f[C]prun\f[R] will print out an error message and kill
the rest of the application.
.SS Process Environment
.PP
Processes in the application inherit their environment from the PSRVR
daemon upon the node on which they are running.
The environment is typically inherited from the user\[cq]s shell.
On remote nodes, the exact environment is determined by the boot MCA
module used.
The \f[C]rsh\f[R] launch module, for example, uses either
\f[C]rsh\f[R]/\f[C]ssh\f[R] to launch the PSRVR daemon on remote nodes,
and typically executes one or more of the user\[cq]s shell-setup files
before launching the daemon.
When running dynamically linked applications which require the
\f[C]LD_LIBRARY_PATH\f[R] environment variable to be set, care must be
taken to ensure that it is correctly set when booting PSRVR.
.PP
See the \[lq]Remote Execution\[rq] section for more details.
.SS Remote Execution
.PP
PSRVR requires that the \f[C]PATH\f[R] environment variable be set to
find executables on remote nodes (this is typically only necessary in
\f[C]rsh\f[R]- or \f[C]ssh\f[R]-based environments \[en] batch/scheduled
environments typically copy the current environment to the execution of
remote jobs, so if the current environment has \f[C]PATH\f[R] and/or
\f[C]LD_LIBRARY_PATH\f[R] set properly, the remote nodes will also have
it set properly).
If PSRVR was compiled with shared library support, it may also be
necessary to have the \f[C]LD_LIBRARY_PATH\f[R] environment variable set
on remote nodes as well (especially to find the shared libraries
required to run user applications).
.PP
However, it is not always desirable or possible to edit shell startup
files to set \f[C]PATH\f[R] and/or \f[C]LD_LIBRARY_PATH\f[R].
The \f[C]--prefix\f[R] option is provided for some simple configurations
where this is not possible.
.PP
The \f[C]--prefix\f[R] option takes a single argument: the base
directory on the remote node where PSRVR is installed.
PSRVR will use this directory to set the remote \f[C]PATH\f[R] and
\f[C]LD_LIBRARY_PATH\f[R] before executing any user applications.
This allows running jobs without having pre-configured the
\f[C]PATH\f[R] and \f[C]LD_LIBRARY_PATH\f[R] on the remote nodes.
.PP
PSRVR adds the basename of the current node\[cq]s \[lq]bindir\[rq] (the
directory where PSRVR\[cq]s executables are installed) to the prefix and
uses that to set the \f[C]PATH\f[R] on the remote node.
Similarly, PSRVR adds the basename of the current node\[cq]s
\[lq]libdir\[rq] (the directory where PSRVR\[cq]s libraries are
installed) to the prefix and uses that to set the
\f[C]LD_LIBRARY_PATH\f[R] on the remote node.
For example:
.TP
Local bindir:
/local/node/directory/bin
.TP
Local libdir:
/local/node/directory/lib64
.PP
If the following command line is used:
.IP
.nf
\f[C]
$ prun --prefix /remote/node/directory
\f[R]
.fi
.PP
PSRVR will add \[lq]/remote/node/directory/bin\[rq] to the
\f[C]PATH\f[R] and \[lq]/remote/node/directory/lib64\[rq] to the
D_LIBRARY_PATH on the remote node before attempting to execute anything.
.PP
The \f[C]--prefix\f[R] option is not sufficient if the installation
paths on the remote node are different than the local node (e.g., if
\[lq]/lib\[rq] is used on the local node, but \[lq]/lib64\[rq] is used
on the remote node), or if the installation paths are something other
than a subdirectory under a common prefix.
.PP
Note that executing \f[C]prun\f[R] via an absolute pathname is
equivalent to specifying \f[C]--prefix\f[R] without the last
subdirectory in the absolute pathname to \f[C]prun\f[R].
For example:
.IP
.nf
\f[C]
$ /usr/local/bin/prun ...
\f[R]
.fi
.PP
is equivalent to
.IP
.nf
\f[C]
$ prun --prefix /usr/local
\f[R]
.fi
.SS Exported Environment Variables
.PP
All environment variables that are named in the form PMIX_* will
automatically be exported to new processes on the local and remote
nodes.
Environmental parameters can also be set/forwarded to the new processes
using the MCA parameter \f[C]mca_base_env_list\f[R].
While the syntax of the \f[C]-x\f[R] option and MCA param allows the
definition of new variables, note that the parser for these options are
currently not very sophisticated - it does not even understand quoted
values.
Users are advised to set variables in the environment and use the option
to export them; not to define them.
.SS Setting MCA Parameters
.PP
The \f[C]-pmca\f[R] switch allows the passing of parameters to various
MCA (Modular Component Architecture) modules.
MCA modules have direct impact on programs because they allow tunable
parameters to be set at run time (such as which BTL communication device
driver to use, what parameters to pass to that BTL, etc.).
.PP
The \f[C]-pmca\f[R] switch takes two arguments: \f[C]<key>\f[R] and
\f[C]<value>\f[R].
The \f[C]<key>\f[R] argument generally specifies which MCA module will
receive the value.
For example, the \f[C]<key>\f[R] \[lq]btl\[rq] is used to select which
BTL to be used for transporting messages.
The \f[C]<value>\f[R] argument is the value that is passed.
For example:
.TP
prun -pmca btl tcp,self -np 1 foo
Tells PSRVR to use the \[lq]tcp\[rq] and \[lq]self\[rq] BTLs, and to run
a single copy of \[lq]foo\[rq] on an allocated node.
.TP
prun -pmca btl self -np 1 foo
Tells PSRVR to use the \[lq]self\[rq] BTL, and to run a single copy of
\[lq]foo\[rq] on an allocated node.
.PP
The \f[C]-pmca\f[R] switch can be used multiple times to specify
different \f[C]<key>\f[R] and/or \f[C]<value>\f[R] arguments.
If the same \f[C]<key>\f[R] is specified more than once, the
\f[C]<value>\f[R]s are concatenated with a comma (\[lq],\[rq])
separating them.
.PP
Note that the \f[C]-pmca\f[R] switch is simply a shortcut for setting
environment variables.
The same effect may be accomplished by setting corresponding environment
variables before running \f[C]prun\f[R].
The form of the environment variables that PSRVR sets is:
.IP
.nf
\f[C]
PMIX_MCA_<key>=<value>
\f[R]
.fi
.PP
Thus, the \f[C]-pmca\f[R] switch overrides any previously set
environment variables.
The \f[C]-pmca\f[R] settings similarly override MCA parameters set in
the $PRTE_PREFIX/etc/psrvr-mca-params.conf or
$HOME/.psrvr/mca-params.conf file.
.PP
Unknown \f[C]<key>\f[R] arguments are still set as environment variable
\[en] they are not checked (by \f[C]prun\f[R]) for correctness.
Illegal or incorrect \f[C]<value>\f[R] arguments may or may not be
reported \[en] it depends on the specific MCA module.
.PP
To find the available component types under the MCA architecture, or to
find the available parameters for a specific component, use the
\f[C]pinfo\f[R] command.
See the \f[I]pinfo(1)\f[R] man page for detailed information on the
command.
.SS Setting MCA parameters and environment variables from file.
.PP
The \f[C]-tune\f[R] command line option and its synonym
\f[C]-pmca mca_base_envar_file_prefix\f[R] allows a user to set mca
parameters and environment variables with the syntax described below.
This option requires a single file or list of files separated by
\[lq],\[rq] to follow.
.PP
A valid line in the file may contain zero or many \[lq]-x\[rq],
\[lq]-pmca\[rq], or \[lq]\[en]pmca\[rq] arguments.
The following patterns are supported: -pmca var val -pmca var
\[lq]val\[rq] -x var=val -x var.
If any argument is duplicated in the file, the last value read will be
used.
.PP
MCA parameters and environment specified on the command line have higher
precedence than variables specified in the file.
.SS Running as root
.PP
The PSRVR team strongly advises against executing \f[C]prun\f[R] as the
root user.
Applications should be run as regular (non-root) users.
.PP
Reflecting this advice, prun will refuse to run as root by default.
To override this default, you can add the \f[C]--allow-run-as-root\f[R]
option to the \f[C]prun\f[R] command line.
.SS Exit status
.PP
There is no standard definition for what \f[C]prun\f[R] should return as
an exit status.
After considerable discussion, we settled on the following method for
assigning the \f[C]prun\f[R] exit status (note: in the following
description, the \[lq]primary\[rq] job is the initial application
started by prun - all jobs that are spawned by that job are designated
\[lq]secondary\[rq] jobs):
.IP \[bu] 2
if all processes in the primary job normally terminate with exit status
0, we return 0
.IP \[bu] 2
if one or more processes in the primary job normally terminate with
non-zero exit status, we return the exit status of the process with the
lowest rank to have a non-zero status
.IP \[bu] 2
if all processes in the primary job normally terminate with exit status
0, and one or more processes in a secondary job normally terminate with
non-zero exit status, we (a) return the exit status of the process with
the lowest rank in the lowest jobid to have a non-zero status, and (b)
output a message summarizing the exit status of the primary and all
secondary jobs.
.IP \[bu] 2
if the cmd line option \[en]report-child-jobs-separately is set, we will
return -only- the exit status of the primary job.
Any non-zero exit status in secondary jobs will be reported solely in a
summary print statement.
.PP
By default, PSRVR records and notes that processes exited with non-zero
termination status.
This is generally not considered an \[lq]abnormal termination\[rq] -
i.e., PSRVR will not abort a job if one or more processes return a
non-zero status.
Instead, the default behavior simply reports the number of processes
terminating with non-zero status upon completion of the job.
.PP
However, in some cases it can be desirable to have the job abort when
any process terminates with non-zero status.
For example, a non-PMIx job might detect a bad result from a calculation
and want to abort, but doesn\[cq]t want to generate a core file.
Or a PMIx job might continue past a call to PMIx_Finalize, but indicate
that all processes should abort due to some post-PMIx result.
.PP
It is not anticipated that this situation will occur frequently.
However, in the interest of serving the broader community, PSRVR now has
a means for allowing users to direct that jobs be aborted upon any
process exiting with non-zero status.
Setting the MCA parameter \[lq]prte_abort_on_non_zero_status\[rq] to 1
will cause PSRVR to abort all processes once any process exits with
non-zero status.
.PP
Terminations caused in this manner will be reported on the console as an
\[lq]abnormal termination\[rq], with the first process to so exit
identified along with its exit status.
.SH RETURN VALUE
.PP
\f[C]prun\f[R] returns 0 if all processes started by \f[C]prun\f[R] exit
after calling PMIx_Finalize.
A non-zero value is returned if an internal error occurred in prun, or
one or more processes exited before calling PMIx_Finalize.
If an internal error occurred in prun, the corresponding error code is
returned.
In the event that one or more processes exit before calling
PMIx_Finalize, the return value of the rank of the process that
\f[C]prun\f[R] first notices died before calling PMIx_Finalize will be
returned.
Note that, in general, this will be the first process that died but is
not guaranteed to be so.
.PP
If the \f[C]--timeout\f[R] command line option is used and the timeout
expires before the job completes (thereby forcing \f[C]prun\f[R] to kill
the job) \f[C]prun\f[R] will return an exit status equivalent to the
value of \f[C]ETIMEDOUT\f[R] (which is typically 110 on Linux and OS X
systems).
